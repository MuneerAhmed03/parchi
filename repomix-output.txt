This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repomix on: 2024-11-16T15:21:50.952Z

================================================================
File Summary
================================================================

Purpose:
--------
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

File Format:
------------
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A separator line (================)
  b. The file path (File: path/to/file)
  c. Another separator line
  d. The full contents of the file
  e. A blank line

Usage Guidelines:
-----------------
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

Notes:
------
- Some files may have been excluded based on .gitignore rules and Repomix's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

Additional Info:
----------------

For more information about Repomix, visit: https://github.com/yamadashy/repomix

================================================================
Repository Structure
================================================================
src/
  handlers/
    gameLogic.ts
    redisManager.ts
    roomManager.ts
  model/
    gameState.ts
  utils/
    GameError.ts
  websockets/
    broadcastManager.ts
    sockethandler.ts
  index.ts
.gitignore
.prettierignore
package.json
tsconfig.json

================================================================
Repository Files
================================================================

================
File: src/handlers/gameLogic.ts
================
import RedisManager from "@/handlers/redisManager";
import { GameError } from "@/utils/GameError";

interface Chit {
  title: string;
  id: string;
}

export default class GameLogic {
  constructor(private redisManager: RedisManager) {}

  async startGame(roomId: string): Promise<void> {
    const players = await this.redisManager.getRoomPlayers(roomId);
    const titles = await this.redisManager.getTitles(roomId);

    const deck = this.createDeck(titles);
    this.shuffleDeck(deck);
    const hands = this.dealHands(deck, players);
    console.log("start game function", roomId);
    await this.redisManager.saveGameState(roomId, {
      players,
      hands,
      currentPlayerIndex: 0,
      gameStatus: "inProgress",
    });
  }

  async playCard(
    roomId: string,
    playerId: string,
    cardIndex: number,
  ): Promise<void> {
    const gameState = await this.redisManager.getGameState(roomId);
    if (gameState.gameStatus !== "inProgress") {
      throw new GameError("Game is not in progress");
    }

    const playerIndex = gameState.players.indexOf(playerId);
    if (playerIndex !== gameState.currentPlayerIndex) {
      throw new GameError("Not your turn");
    }

    const card = gameState.hands[playerIndex][cardIndex];
    gameState.hands[playerIndex].splice(cardIndex, 1);

    const nextPlayerIndex =
      (gameState.currentPlayerIndex + 1) % gameState.players.length;
    gameState.hands[nextPlayerIndex].push(card);
    gameState.currentPlayerIndex = nextPlayerIndex;

    await this.redisManager.saveGameState(roomId, gameState);
  }

  async claimWin(roomId: string, playerId: string): Promise<boolean> {
    const gameState = await this.redisManager.getGameState(roomId);
    const playerIndex = gameState.players.indexOf(playerId);
    const hand = gameState.hands[playerIndex];

    if (this.verifyWin(hand)) {
      gameState.gameStatus = "finished";
      gameState.winner = playerId;
      await this.redisManager.saveGameState(roomId, gameState);
      return true;
    }

    return false;
  }

  createDeck(titles: string[]): Chit[] {
    let deck: Chit[] = [];
    titles.forEach((title) => {
      for (let i = 0; i < 4; i++) {
        deck.push({ title, id: `${title}-${i}` });
      }
    });
    return deck;
  }

  shuffleDeck(deck: Chit[]) {
    for (let i = deck.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [deck[i], deck[j]] = [deck[j], deck[i]];
    }
  }

  dealHands(deck: Chit[], players: string[]) {
    const hands: Chit[][] = [];
    for (let i = 0; i < players.length; i++) {
      hands.push(deck.splice(0, 4));
    }
    return hands;
  }

  verifyWin(hand: Chit[]): boolean {
    return hand.every((chit) => chit.title === hand[0].title);
  }
}

================
File: src/handlers/redisManager.ts
================
import { createClient, RedisClientType } from "redis";
import GameState from "@/model/gameState";

export default class RedisManager {
  private client: RedisClientType;

  constructor() {
    this.client = createClient();
    this.client.connect();
  }

  // async createRoom(roomId: string, playerId: string): Promise<void> {
  //   // await this.client.multi()
  //   //   .hSet(`room:${roomId}`, "state", "lobby")
  //   //   .sAdd(`room:${roomId}:players`, playerId)
  //   //   .exec();


  // }
  async createRoom(roomId: string,playerId:string) :Promise<void>{
    // await this.client.hSet(`room:${roomId}`, "state", "lobby")
    await this.client.multi()
                    .hSet(`room:${roomId}`, "state", "lobby")
                    .sAdd(`room:${roomId}:players`, playerId)
                    .exec()
  }

  async addPlayerToRoom(roomId: string, playerName: string): Promise<void> {
    console.log(`${playerName} added to the room`)
    await this.client.sAdd(`room:${roomId}:players`, playerName);
  }

  async removePlayerFromRoom(roomId: string, playerName: string): Promise<void> {
    await this.client.sRem(`room:${roomId}:players`, playerName);
  }

  async getRoomPlayers(roomId: string): Promise<string[]> {
    return await this.client.sMembers(`room:${roomId}:players`);
  }

  async getRoomPlayerCount(roomId: string): Promise<number> {
    return await this.client.sCard(`room:${roomId}:players`);
  }

  async submitTitleAndCheck(roomId: string, title: string): Promise<boolean> {
    const result = await this.client.multi()
      .sAdd(`room:${roomId}:titles`, title)
      .sCard(`room:${roomId}:titles`)
      .sCard(`room:${roomId}:players`)
      .exec();

    if (!result) {
      throw new Error("Redis transaction failed");
    }

    const [, submittedCount, playerCount] = result;
    return Number(submittedCount) === Number(playerCount);
  }

  async getTitles(roomId: string): Promise<string[]> {
    return await this.client.sMembers(`room:${roomId}:titles`);
  }

  async saveGameState(roomId: string, gameState: GameState): Promise<void> {
    await this.client.set(`room:${roomId}:gameState`, JSON.stringify(gameState));
  }

  async getGameState(roomId: string): Promise<GameState> {
    const gameState = await this.client.get(`room:${roomId}:gameState`);
    if (!gameState) {
      throw new Error("Game state not found");
    }
    return JSON.parse(gameState);
  }

  async setGameStatus(roomId: string, status: string): Promise<void> {
    await this.client.hSet(`room:${roomId}`, "state", status);
  }

  async getGameStatus(roomId: string): Promise<string> {
    return (await this.client.hGet(`room:${roomId}`, "state")) || "unknown";
  }

  async removeRoom(roomId: string): Promise<void> {
    await this.client.multi()
      .del(`room:${roomId}`)
      .del(`room:${roomId}:players`)
      .del(`room:${roomId}:titles`)
      .del(`room:${roomId}:gameState`)
      .exec();
  }

  async isRoomFull(roomId: string): Promise<boolean> {
    const playerCount = await this.getRoomPlayerCount(roomId);
    return playerCount >= 4;
  }

  async close(): Promise<void> {
    await this.client.quit();
  }
}

================
File: src/handlers/roomManager.ts
================
import { v4 as uuidv4 } from "uuid";
import RedisManager from "@/handlers/redisManager";

export default class RoomManager {
  private redisManager: RedisManager;

  constructor() {
    this.redisManager = new RedisManager();
  }

  async createRoom(playerId:string): Promise<string> {
    const roomId = uuidv4(); 
    await this.redisManager.createRoom(roomId,playerId);
    return roomId;
  }

  async joinRoom(roomId: string, playerName: string): Promise<boolean> {
    // this.logCallerInfo()
    const isRoomFull = await this.redisManager.isRoomFull(roomId);
    if (isRoomFull) {
      return false;
    }
    await this.redisManager.addPlayerToRoom(roomId, playerName);
    return true;
  }
}

================
File: src/model/gameState.ts
================
export default interface GameState {
  players: string[];
  hands: { title: string; id: string }[][];
  currentPlayerIndex: number;
  gameStatus: string;
  winner?: string;
}

================
File: src/utils/GameError.ts
================
export class GameError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "GameError";
  }
}

================
File: src/websockets/broadcastManager.ts
================
import WebSocket from "ws";
import RedisManager from "@/handlers/redisManager";
import GameState from "@/model/gameState";

export default class BroadCastManager {
  private clients: Map<string, WebSocket> = new Map();

  constructor(private redisManager: RedisManager) {}

  addClient(playerId: string, ws: WebSocket) {
    this.clients.set(playerId, ws);
  }

  removeClient(roomId: string) {
    this.clients.delete(roomId);
  }

  async broadCastGameState(roomId: string): Promise<void> {
    const keys = Array.from(this.clients.keys());
    console.log(keys);
    console.log("game state broadcasting attempt")
    const gameState = await this.redisManager.getGameState(roomId);
    // console.log(JSON.stringify(gameState));
    gameState.players.forEach((player, index) => {
      const playerWs = this.clients.get(player);
      if (playerWs && playerWs.readyState === WebSocket.OPEN) {
        const playerView =  this.getPlayerView(gameState, index);
        // console.log("player view: ",playerView);
        playerWs.send(
          JSON.stringify({
            type: "gameState",
            data: playerView,
          }),
        );
      }
    });
  }

  async broadcastLobby(roomId:string) : Promise<void>{
    const players = await this.redisManager.getRoomPlayers(roomId)
    players.forEach(player => {
      const playerWs = this.clients.get(player);
      if (playerWs && playerWs.readyState === WebSocket.OPEN){
        playerWs.send(
          JSON.stringify({
            type: "lobby",
            data : players,
          })
        )
      }
    })
  }

  getPlayerView(gameState: GameState, playerIndex: number) {
    const playerView = {
      players: gameState.players,
      currentPlayerIndex: gameState.currentPlayerIndex,
      gameStatus: gameState.gameStatus,
      winner: gameState.winner,
      hand: gameState.hands[playerIndex],
    };
    return playerView;
  }

  braoadCastToRoon(roomId: string, message: any) {
    this.redisManager.getRoomPlayers(roomId).then((players) => {
      players.forEach((player) => {
        const playerWs = this.clients.get(player);
        if (playerWs && playerWs.readyState === WebSocket.OPEN) {
          playerWs.send(JSON.stringify(message));
        }
      });
    });
  }

  broadcastError(player:string, errorMessage:string){
    const playerWs=this.clients.get(player);
    if(playerWs && playerWs.readyState === WebSocket.OPEN){
      playerWs.send(JSON.stringify({type :"error",message: errorMessage}))
    }
  }
}

================
File: src/websockets/sockethandler.ts
================
import { WebSocket, WebSocketServer } from "ws";
import * as http from "http";
import RedisManager from "@/handlers/redisManager";
import BroadCastManager from "@/websockets/broadcastManager";
import GameLogic from "@/handlers/gameLogic";
import { GameError } from "@/utils/GameError";

export default class WebSocketHandler {
  constructor(
    private gameLogic: GameLogic,
    private redisManager: RedisManager,
    private broadcastManager: BroadCastManager,
  ) {}

  onUpgrade(req: http.IncomingMessage, socket: any, head: Buffer) {
    const wss = new WebSocketServer({ noServer: true });
    wss.handleUpgrade(req, socket, head, (ws) => {
      this.handleConnection(ws);
    });
  }

  private handleConnection(ws: WebSocket) {
    ws.on("message", async (message: string) => {
      const data = JSON.parse(message);
      await this.handleMessage(ws, data);
    });
    ws.on("close", async () => {});
  }

  private async handleMessage(ws: WebSocket, data: any) {
    try{
    switch (data.type) {
      case "join_room":
        console.log(`${data.playerId} requested to join with data as ${JSON.stringify(data)}`)
        await this.handleJoinRoom(data.roomId, data.playerId, ws);
        break;
      case "submit_title":
        await this.handleSubmitTitle(data.roomId, data.title);
        break;
      case "play_card":
        await this.handlePlayCard(data.roomId, data.playerId, data.cardIndex);
        break;
      case "claim_win":
        await this.handleClaimWin(data.roomId, data.playerId);
    }
  }catch(error){
    console.error("Error handling messgae:", error);
    if( error instanceof GameError){
      this.broadcastManager.broadcastError(data.playerId,error.message);
    }else{
      this.broadcastManager.broadcastError(data.playerId,"An unexpected error occured");
    }
  }
  }

  private async handleJoinRoom(
    roomId: string,
    playerId: string,
    ws: WebSocket,
  ) {
    // const isRoomFull = await this.redisManager.isRoomFull(roomId);
    // if (isRoomFull) {
    //   ws.send(JSON.stringify({ type: "error", message: "Room is full" }));
    //   return;
    // }
    this.broadcastManager.addClient(playerId, ws);
    await this.broadcastManager.broadcastLobby(roomId);
    // await this.broadcastManager.broadCastGameState(roomId);
  }

  private async handleSubmitTitle( roomId: string, title: string) {
      const allTitlesSubmitted = await this.redisManager.submitTitleAndCheck(roomId, title);
      if (allTitlesSubmitted) {
        await this.gameLogic.startGame(roomId);
        console.log("game started")
        await this.delay(2000);
        await this.broadcastManager.broadCastGameState(roomId);
      }
  }
  delay(ms: number) {
    return new Promise(resolve => setTimeout(resolve, ms));
}
  private async handlePlayCard(
    roomId: string,
    playerId: string,
    cardIndex: number,
  ) {

    await this.gameLogic.playCard(roomId, playerId, cardIndex);
    await this.broadcastManager.broadCastGameState(roomId);
    console.log(`${playerId} passes ${cardIndex}`);
  }

  private async handleClaimWin(roomId: string, playerId: string) {
    const isWinner = await this.gameLogic.claimWin(roomId, playerId);
    if (isWinner) {
      this.broadcastManager.braoadCastToRoon(roomId, {
        type: "game_end",
        winner: playerId,
      });
    }
    await this.broadcastManager.broadCastGameState(roomId);
  }
}

================
File: src/index.ts
================
import express from "express";
import * as http from "http";
import GameLogic from "@/handlers/gameLogic";
import RedisManager from "@/handlers/redisManager";
import RoomManager from "@/handlers/roomManager";
import WebSocketHandler from "@/websockets/sockethandler";
import BroadcastManager from "@/websockets/broadcastManager";
import bodyParser from "body-parser";

const app = express();
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));

const server = http.createServer(app);

const redisManager = new RedisManager();
const gameLogic = new GameLogic(redisManager);
const roomManager = new RoomManager();
const broadcastManager = new BroadcastManager(redisManager);
const webSocketHandler = new WebSocketHandler(
  gameLogic,
  redisManager,
  broadcastManager,
);

app.get("/health", async (req, res) => {
  res.send("Running");
});

app.post("/create-room", async (req, res) => {
  const playerName = req.body.playerName;
  const roomId = await roomManager.createRoom(playerName);
  res.send(roomId);
});

app.post("/join-room", async (req, res) => {
  const roomId = req.body.roomId;
  const playerName = req.body.playerName;
  const success = await roomManager.joinRoom(roomId, playerName);
  res.send({ success });
});

server.on("upgrade", (req, socket, head) => {
  webSocketHandler.onUpgrade(req, socket, head);
});
const PORT = process.env.PORT || 3000;
server.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});

================
File: .gitignore
================
# Node.js
node_modules/
dist/

# TypeScript
*.tsbuildinfo

# Logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# IDEs and editors
.vscode/
.idea/
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?

# Miscellaneous
.DS_Store
Thumbs.db

================
File: .prettierignore
================
# Ignore node_modules
node_modules

# Ignore build outputs
dist
build

# Ignore specific files
*.min.js
*.json
*.md

# Ignore all files in the `public` directory
public/*

================
File: package.json
================
{
  "name": "parchi",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "dev": "ts-node-dev --respawn --transpile-only --require tsconfig-paths/register src/index.ts",
    "build": "tsc",
    "start": "tsc -b node dist/index.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "body-parser": "^1.20.3",
    "express": "^4.21.1",
    "redis": "^4.7.0",
    "uuid": "^10.0.0",
    "ws": "^8.18.0"
  },
  "devDependencies": {
    "@types/body-parser": "^1.19.5",
    "@types/express": "^5.0.0",
    "@types/node": "^22.7.6",
    "@types/uuid": "^10.0.0",
    "@types/ws": "^8.5.12",
    "prettier": "^3.3.3",
    "ts-node-dev": "^2.0.0",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.6.3"
  }
}

================
File: tsconfig.json
================
{
  "compilerOptions": {
    "target": "ES6",                                
    "module": "commonjs",                           
    "strict": true,                                
    "esModuleInterop": true,                       
    "skipLibCheck": true,                          
    "forceConsistentCasingInFileNames": true,      
    "outDir": "./dist",                            
    "rootDir": "./src",
    "baseUrl": "./",
    "paths": {
      "@/*": ["src/*"]
    }                             
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}
