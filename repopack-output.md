This file is a merged representation of the entire codebase, combining all repository files into a single document.
Generated by Repopack on: 2024-12-25T11:47:45.181Z

# File Summary

## Purpose
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.

## File Format
The content is organized as follows:
1. This summary section
2. Repository information
3. Repository structure
4. Multiple file entries, each consisting of:
  a. A header with the file path (## File: path/to/file)
  b. The full contents of the file in a code block

## Usage Guidelines
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.

## Notes
- Some files may have been excluded based on .gitignore rules and Repopack's
  configuration.
- Binary files are not included in this packed representation. Please refer to
  the Repository Structure section for a complete list of file paths, including
  binary files.

## Additional Info

For more information about Repopack, visit: https://github.com/yamadashy/repopack

# Repository Structure
```
src/
  handlers/
    gameLogic.ts
    redisManager.ts
    roomManager.ts
  model/
    gameState.ts
  utils/
    ErrorHandler.ts
    GameError.ts
    roomIdGenerator.ts
  websockets/
    broadcastManager.ts
    sockethandler.ts
  index.ts
.gitignore
.prettierignore
package.json
tsconfig.json
```

# Repository Files

## File: src/handlers/gameLogic.ts
```typescript
import RedisManager from "@/handlers/redisManager";
import { GameError } from "@/utils/GameError";
import { ErrorHandler } from '@/utils/ErrorHandler';

interface Chit {
  title: string;
  id: string;
}

export default class GameLogic {
  constructor(private redisManager: RedisManager) {}

  async startGame(roomId: string): Promise<void> {
    const players = await this.redisManager.getRoomPlayers(roomId);
    const titles = await this.redisManager.getTitles(roomId);

    const deck = this.createDeck(titles);
    this.shuffleDeck(deck);
    const hands = this.dealHands(deck, players.length);
    console.log("start game function", roomId);
    await this.redisManager.saveGameState(roomId, {
      players,
      hands,
      currentPlayerIndex: 0,
      gameStatus: "inProgress",
    });
  }

  async playCard(
    roomId: string,
    playerId: string,
    cardIndex: number,
  ): Promise<void> {
    try {
      console.log("game Logic:",roomId)
      const gameState = await this.redisManager.getGameState(roomId);
      
      if (gameState.gameStatus !== "inProgress") {
        throw new GameError("Game is not in progress");
      }

      const playerIndex = gameState.players.findIndex(player => player.id === playerId);
      if (playerIndex !== gameState.currentPlayerIndex) {
        throw new GameError("Not your turn");
      }

      if (cardIndex >= gameState.hands[playerIndex].length) {
        throw new GameError("Invalid card index");
      }

      const card = gameState.hands[playerIndex][cardIndex];
      gameState.hands[playerIndex].splice(cardIndex, 1);

      const nextPlayerIndex =
        (gameState.currentPlayerIndex + 1) % gameState.players.length;
      gameState.hands[nextPlayerIndex].push(card);
      gameState.currentPlayerIndex = nextPlayerIndex;

      await this.redisManager.saveGameState(roomId, gameState);
    } catch (error) {
      throw ErrorHandler.handleError(error as Error, 'GameLogic.playCard', playerId);
    }
  }

  async claimWin(roomId: string, playerId: string): Promise<boolean> {
    const gameState = await this.redisManager.getGameState(roomId);
    const playerIndex = gameState.players.findIndex(player => player.id === playerId);
    const hand = gameState.hands[playerIndex];

    if (this.verifyWin(hand)) {
      gameState.gameStatus = "finished";
      gameState.winner = playerId;
      await this.redisManager.saveGameState(roomId, gameState);
      return true;
    }
    return false;
  }

  createDeck(titles: string[]): Chit[] {
    let deck: Chit[] = [];
    titles.forEach((title) => {
      for (let i = 0; i < 4; i++) {
        deck.push({ title, id: `${title}-${i}` });
      }
    });
    return deck;
  }

  shuffleDeck(deck: Chit[]) {
    for (let i = deck.length - 1; i > 0; i--) {
      const j = Math.floor(Math.random() * (i + 1));
      [deck[i], deck[j]] = [deck[j], deck[i]];
    }
  }

  dealHands(deck: Chit[], players: number) {
    const hands: Chit[][] = [];
    for (let i = 0; i < players; i++) {
      hands.push(deck.splice(0, 4));
    }
    return hands;
  }

  verifyWin(hand: Chit[]): boolean {
    return hand.every((chit) => chit.title === hand[0].title);
  }
}
```

## File: src/handlers/redisManager.ts
```typescript
import { createClient, RedisClientType } from "redis";
import GameState, { Player } from "@/model/gameState";
import { ErrorHandler } from '@/utils/ErrorHandler';
import { GameError } from "@/utils/GameError";
import { connect } from "http2";

export default class RedisManager {
  private client: RedisClientType;
  private static instance: RedisManager;

  private constructor() {
    this.client = createClient();
    this.client.connect();
  }

  public static getInstance(): RedisManager {
    if (!RedisManager.instance) {
      this.instance = new RedisManager
    }
    return RedisManager.instance;
  }


  async roomExists(roomId: string): Promise<boolean> {
    const exists = await this.client.exists(`room:${roomId}`)
    return exists === 1;
  }


  async createRoom(roomId: string, playerId: string, playerName: string): Promise<void> {
    try {
      console.log(` player ${playerId} created the room ${roomId}`)
      await this.client.multi()
        .hSet(`room:${roomId}`, "state", "lobby")
        .expire(`room:${roomId}`, 1800)
        .hSet(`room:${roomId}:players`, playerId, JSON.stringify({
          name: playerName,
          connected: "true",
          title: null
        }))
        .expire(`room:${roomId}:players`, 1800)
        .exec();
    } catch (error) {
      throw ErrorHandler.handleError(error as Error, 'RedisManager.createRoom', playerId);
    }
  }

  async addPlayerToRoom(roomId: string, playerId: string, playerName: string): Promise<void> {
    console.log(`${playerId} added to the room`)
    const maxplayers = 4;
    const playerCount = await this.getRoomPlayerCount(roomId);

    if (playerCount > maxplayers) {
      throw new Error("Room Full")
    }

    await this.client.hSet(`room:${roomId}:players`, playerId, JSON.stringify(
      {
        name: playerName,
        connected: true,
        title: null
      }));
    console.log(`${playerId} successfully added to room ${roomId}`);

  }

  async removePlayerFromRoom(roomId: string, playerId: string): Promise<void> {
    await this.client.hDel(`room:${roomId}:players`, playerId);
  }

  async getRoomPlayers(roomId: string): Promise<Player[]> {
    const players = await this.client.hGetAll(`room:${roomId}:players`)
    return Object.keys(players).map((key) => {
      const parsedVal = JSON.parse(players[key]);
      return {
        id: key,
        name: parsedVal.name,
        isConnected: parsedVal.connected,
        title: parsedVal.title
      }
    });
  }

  async getRoomPlayerCount(roomId: string): Promise<number> {
    return await this.client.hLen(`room:${roomId}:players`);
  }

  async submitTitleAndCheck(roomId: string, title: string, playerId: string): Promise<boolean> {
    // console.log(`submit title and check arguments: title:${title} room:${roomId} player:${playerId}`)
    const playerData = await this.client.hGet(`room:${roomId}:players`, playerId)

    if (!playerData) {
      throw new Error(`player ${playerId} doesnt exist in room ${roomId}`);
    }
    const player = JSON.parse(playerData);
    player.title = title

    const result = await this.client.multi().hSet(`room:${roomId}:players`, playerId, JSON.stringify(player))
      .sAdd(`room:${roomId}:titles`, title)
      .sCard(`room:${roomId}:titles`)
      .hLen(`room:${roomId}:players`)
      .exec();

    if (!result) {
      throw new Error("Redis transaction failed");
    }
    console.log("submit title query result", result)
    const [, , submittedCount, playerCount] = result;
    console.log(`submit title result: submitted count:${submittedCount} and playeCount:${playerCount}`)
    return Number(submittedCount) === 4 && Number(playerCount) === 4;
  }

  async getTitles(roomId: string): Promise<string[]> {
    return await this.client.sMembers(`room:${roomId}:titles`);
  }

  async saveGameState(roomId: string, gameState: GameState): Promise<void> {
    await this.client.set(`room:${roomId}:gameState`, JSON.stringify(gameState))
    await this.updateTtl(roomId);
  }

  async updateTtl(roomId: string) {
    await this.client.multi().expire(`room:${roomId}:gameState`, 1800).expire(`room:${roomId}`, 1800).expire(`room:${roomId}:titles`, 1800).expire(`room:${roomId}:players`, 1800).exec();
  }

  async getGameState(roomId: string): Promise<GameState> {
    try {
      console.log("game state being retrieved from redis manager:", roomId)
      const gameState = await this.client.get(`room:${roomId}:gameState`);
      if (!gameState) {
        throw new GameError("Game state not found");
      }
      return JSON.parse(gameState);
    } catch (error) {
      throw ErrorHandler.handleError(error as Error, 'RedisManager.getGameState');
    }
  }

  async setGameStatus(roomId: string, status: string): Promise<void> {
    await this.client.hSet(`room:${roomId}`, "state", status);
  }

  async getGameStatus(roomId: string): Promise<string> {
    return (await this.client.hGet(`room:${roomId}`, "state")) || "unknown";
  }

  async removeRoom(roomId: string): Promise<void> {
    await this.client.multi()
      .del(`room:${roomId}`)
      .del(`room:${roomId}:players`)
      .del(`room:${roomId}:titles`)
      .del(`room:${roomId}:gameState`)
      .exec();
  }

  async isRoomFull(roomId: string): Promise<boolean> {
    const playerCount = await this.getRoomPlayerCount(roomId);
    return playerCount >= 4;
  }

  async close(): Promise<void> {
    await this.client.quit();
  }

  async setPlayerConnection(playerId: string, roomId: string, isConnected: boolean): Promise<void> {
    const playerData = await this.client.hGet(`room:${roomId}:players`, playerId);
    if (playerData) {
      const player = JSON.parse(playerData);
      player.connected = isConnected;
      await this.client.hSet(`room:${roomId}:players`, playerId, JSON.stringify(player));
    }
  }


  async isPlayerConnected(playerId: string, roomId: string): Promise<boolean> {
    const playerData = await this.client.hGet(`room:${roomId}:players`, playerId);
    if (!playerData) return false;

    const player = JSON.parse(playerData);
    return player.connected === true;
  }

  async getPlayerRoom(playerId: string): Promise<string | null> {
    return await this.client.hGet('player_room', playerId) || "unknown";
  }

  async handlePlayerDisconnect(playerId: string) {
    const roomId = await this.getPlayerRoom(playerId)
    if (roomId) {
      await this.setPlayerConnection(playerId, roomId, false);

      const connectedPlayers = (await this.getRoomPlayers(roomId)).filter(player => player.isConnected === true)
      if (connectedPlayers.length == 0) {
        await this.cleanupRoom(roomId)
      }
    }
  }

  async replacePlayer(roomId:string,oldPlayerId:string,newPlayerId:string,newPlayerName:string):Promise<void>{
    const gameState =  await this.getGameState(roomId);
    const playerIndex = gameState.players.findIndex(p=> p.id === oldPlayerId);
    const playerData = await this.client.hGet(`room:${roomId}:players`, oldPlayerId)

    if(playerIndex === -1 || !playerData){
        throw new GameError("Orignal player not found in game State");
    }

    const title = JSON.parse(playerData).title;

    gameState.players[playerIndex]={
      id:newPlayerId,
      name:newPlayerName,
      isConnected: true
    };

    await this.saveGameState(roomId,gameState);
    await this.client.hSet(`room:${roomId}:players`,newPlayerId,JSON.stringify({
      name:newPlayerName,
      connected:true,                                                                  title                                                      
    }))

    await this.client.hDel(`room:${roomId}:players`,oldPlayerId)
  }

  async getDisconnectedPlayer(roomId:string):Promise<string|null>{
    const players = await this.getRoomPlayers(roomId);
    const disconnected = players.find(player=>!player.isConnected);
    return disconnected ? disconnected.id : null
  }

  async cleanupRoom(roomId: string) {
    const multi = this.client.multi();
    multi.del(`room:${roomId}:players`);
    multi.del(`room:${roomId}:titles`);
    multi.del(`room:${roomId}:gameState`);
    multi.del(`room:${roomId}`);

    await multi.exec();
  }

}
```

## File: src/handlers/roomManager.ts
```typescript
import { v4 as uuidv4 } from "uuid";
import RedisManager from "@/handlers/redisManager";
import { RoomIdGenerator } from "@/utils/roomIdGenerator";

export default class RoomManager {
  private redisManager: RedisManager;
  private roomIdGenerator: RoomIdGenerator;

  constructor() {
    this.redisManager = RedisManager.getInstance();
    this.roomIdGenerator = RoomIdGenerator.getInstance(this.redisManager)
  }

  async createRoom(playerId:string,playerName:string): Promise<string> {
    const roomId = await this.roomIdGenerator.generateRoomId();
    await this.redisManager.createRoom(roomId,playerId,playerName);
    return roomId;
  }

  async joinRoom(roomId: string, playerId: string,playerName:string): Promise<boolean> {
    const gameStatus = await this.redisManager.getGameStatus(roomId);

    if(gameStatus === "inProgress"){
      const disconnectedPlayerId = await this.redisManager.getDisconnectedPlayer(roomId);
      if(disconnectedPlayerId){
        await this.redisManager.replacePlayer(roomId,disconnectedPlayerId,playerId,playerName)
        return true;
      }
      return false;
    }

    const isRoomFull = await this.redisManager.isRoomFull(roomId);
    if (isRoomFull) {
      console.log("room full");
      return false;
    }
    await this.redisManager.addPlayerToRoom(roomId, playerId,playerName);
    return true;
  }
}
```

## File: src/model/gameState.ts
```typescript
export default interface GameState {
  players: Player[];
  hands: { title: string; id: string }[][];
  currentPlayerIndex: number;
  gameStatus: string;
  winner?: string;
}

export interface PlayerView {
  playerIndex:number
  players: Player[];
  hand: { title: string; id: string }[];
  currentPlayerIndex: number;
  gameStatus: string;
  winner?: string;
}

export interface Player {
  id:string,
  name:string,
  isConnected:boolean
}
```

## File: src/utils/ErrorHandler.ts
```typescript
import winston from 'winston';
import { GameError } from './GameError';

export class ErrorHandler {
  private static logger = winston.createLogger({
    level: 'error',
    format: winston.format.combine(
      winston.format.timestamp(),
      winston.format.json()
    ),
    transports: [
      new winston.transports.File({ filename: 'error.log' }),
      new winston.transports.Console()
    ]
  });

  static handleError(error: Error, context: string, playerId?: string) {
    const errorDetails = {
      context,
      playerId,
      message: error.message,
      stack: error.stack,
      timestamp: new Date().toISOString()
    };

    this.logger.error(errorDetails);

    if (error instanceof GameError) {
      return error;
    }
    
    return new GameError('An unexpected error occurred');
  }

  static logInfo(message: string, context: string, data?: any) {
    this.logger.info({
      context,
      message,
      data,
      timestamp: new Date().toISOString()
    });
  }
}
```

## File: src/utils/GameError.ts
```typescript
export class GameError extends Error {
  constructor(message: string) {
    super(message);
    this.name = "GameError";
  }
}
```

## File: src/utils/roomIdGenerator.ts
```typescript
import RedisManager from "@/handlers/redisManager";

export class RoomIdGenerator {
    private static instance: RoomIdGenerator;
    private redisManager: RedisManager;
    private roomMap: Map<string, number>;
    private availableIds: string[]

    private constructor(redisManager: RedisManager) {
        this.redisManager = redisManager;
        this.roomMap = new Map();
        this.availableIds = [];

        for (let i = 1000; i <= 9999; i++) {
            const id = i.toString()
            this.roomMap.set(id, 0);
            this.availableIds.push(id)
        }
    }

    public static getInstance(redisManager: RedisManager): RoomIdGenerator {
        if (!RoomIdGenerator.instance) {
            this.instance = new RoomIdGenerator(redisManager);

        }
        return RoomIdGenerator.instance;
    }

    async generateRoomId(): Promise<string> {
        if (this.availableIds.length === 0) {
            throw new Error("No rooms avaialable");
        }

        const roomIndex = Math.floor(Math.random() * this.availableIds.length);
        const roomId = this.availableIds[roomIndex];

        this.availableIds[roomIndex] = this.availableIds[this.availableIds.length - 1];
        this.availableIds.pop();

        const exists = await this.redisManager.roomExists(roomId);
        if (!exists) {
            this.roomMap.set(roomId, 1);
            return roomId
        }

        this.roomMap.set(roomId, 1);
        return this.generateRoomId();
    }

    releaseRoom(roomId: string): void {
        if (this.roomMap.get(roomId) === 1) {
            this.roomMap.set(roomId, 0);
            this.availableIds.push(roomId)
        }
    }

}
```

## File: src/websockets/broadcastManager.ts
```typescript
import WebSocket from "ws";
import RedisManager from "@/handlers/redisManager";
import GameState, {PlayerView} from "@/model/gameState";

export default class BroadCastManager {
  private heartbeatIntervals: Map<string, NodeJS.Timeout> = new Map();

  constructor(private redisManager: RedisManager) {}

  async addClient(playerId: string, roomId: string, ws: WebSocket) {
    await this.redisManager.setPlayerConnection(playerId, roomId, true);

    this.clearHeartbeat(playerId);

    const heartbeat = setInterval(async () => {
      if (ws.readyState === WebSocket.OPEN) {
        ws.ping();
      } else {
        this.clearHeartbeat(playerId);
        await this.redisManager.handlePlayerDisconnect(playerId);
      }
    }, 60000);

    this.heartbeatIntervals.set(playerId, heartbeat);

    ws.on('close', async () => {
      this.clearHeartbeat(playerId);
      await this.redisManager.handlePlayerDisconnect(playerId);
    });

    ws.on('error', async () => {
      this.clearHeartbeat(playerId);
      await this.redisManager.handlePlayerDisconnect(playerId);
    });
  }

  private clearHeartbeat(playerId: string) {
    const interval = this.heartbeatIntervals.get(playerId);
    if (interval) {
      clearInterval(interval);
      this.heartbeatIntervals.delete(playerId);
    }
  }
  async cleanup() {
    for (const [playerId, interval] of this.heartbeatIntervals.entries()) {
      clearInterval(interval);
      await this.redisManager.handlePlayerDisconnect(playerId);
    }
    this.heartbeatIntervals.clear();
  }

  async broadCastGameState(roomId: string, wsMap: Map<string, WebSocket>, messageType?: string): Promise<void> {
    const gameState = await this.redisManager.getGameState(roomId);
    const connectedPlayers = (await this.redisManager.getRoomPlayers(roomId))
      .filter(player => player.isConnected === true);
  
    for (const player of connectedPlayers) {
      const ws = wsMap.get(player.id);
      if (ws?.readyState === WebSocket.OPEN) {
        const playerIndex = gameState.players.findIndex(x => x.id === player.id);
        if (playerIndex !== -1) {
          const playerView = this.getPlayerView(gameState, playerIndex);
          ws.send(
            JSON.stringify({
              type: messageType ? messageType : "gameState",
              data: playerView,
            })
          );
        }
      }
    }
  }

  async broadcastLobby(roomId:string, wsMap:Map<string,WebSocket>) : Promise<void>{
    console.log("lobby broadcast called");
    try {
      console.log("room id passed to broadcast lobby:",roomId);
    const players =  await this.redisManager.getRoomPlayers(roomId);
    console.log("players",players);
    const connectedPlayers = (await this.redisManager.getRoomPlayers(roomId)).filter(player => player.isConnected === true)
    for (const player of connectedPlayers){
      const ws = wsMap.get(player.id);
      console.log("sending message to: ",player.id);
      // console.log("ws state: ", wsMap);
      if(ws?.readyState === WebSocket.OPEN){
        ws.send(
          JSON.stringify({
            type:"lobby",
            data: players,
          })
        )
      }
    }}catch(error){
      console.log("lobby broadcast error",error);
    }
  }

  getPlayerView(gameState: GameState, playerIndex: number) : PlayerView {
    const playerView = {
      playerIndex,
      players: gameState.players,
      currentPlayerIndex: gameState.currentPlayerIndex,
      gameStatus: gameState.gameStatus,
      winner: gameState.winner,
      hand: gameState.hands[playerIndex],
    };
    return playerView;
  }

  broadCastToRoom(roomId: string, message: any, wsMap:Map<string,WebSocket>) {
    this.redisManager.getRoomPlayers(roomId).then((players) => {
      players.forEach((player) => {
        const playerWs =  wsMap.get(player.id);
        if (playerWs && playerWs.readyState === WebSocket.OPEN) {
          playerWs.send(JSON.stringify(message));
        }
      });
    });
  }

  broadcastError(player:string, errorMessage:string,wsMap:Map<string,WebSocket>){
    const playerWs=wsMap.get(player);
    if(playerWs && playerWs.readyState === WebSocket.OPEN){
      playerWs.send(JSON.stringify({type :"error",message: errorMessage}))
    }
  }
}
```

## File: src/websockets/sockethandler.ts
```typescript
import { WebSocket, WebSocketServer } from "ws";
import * as http from "http";
import RedisManager from "@/handlers/redisManager";
import BroadCastManager from "@/websockets/broadcastManager";
import GameLogic from "@/handlers/gameLogic";
import { GameError } from "@/utils/GameError";
import { ErrorHandler } from "@/utils/ErrorHandler";

export default class WebSocketHandler {
  private wsMap: Map<string, WebSocket> = new Map();
  private heartbeatInterval = 30000; // 30 seconds

  constructor(
    private gameLogic: GameLogic,
    private redisManager: RedisManager,
    private broadcastManager: BroadCastManager,
  ) {
    setInterval(this.checkConnections.bind(this), this.heartbeatInterval);
  }

  private async checkConnections(): Promise<void> {
    for (const [playerId, ws] of this.wsMap.entries()) {
      if (!this.isAlive(ws)) {
        await this.handleDisconnect(playerId, ws);
      } else {
        this.ping(ws);
      }
    }
  }

  private isAlive(ws: WebSocket): boolean {
    return ws.readyState === WebSocket.OPEN;
  }

  private ping(ws: WebSocket) {
    try {
      ws.ping();
    } catch (error) {
      console.error('Ping failed:', error);
    }
  }

  private async handleDisconnect(playerId: string, ws: WebSocket) {
    ws.terminate();
    this.wsMap.delete(playerId);
    await this.redisManager.handlePlayerDisconnect(playerId);
  }

  onUpgrade(req: http.IncomingMessage, socket: any, head: Buffer) {
    console.log("requested");
    const wss = new WebSocketServer({ noServer: true });
    wss.handleUpgrade(req, socket, head, (ws) => {
      this.handleConnection(ws);
    });
  }

  private handleConnection(ws: WebSocket) {
    ws.on("message", async (message: string) => {
      try {
        const data = JSON.parse(message);
        await this.handleMessage(ws, data);
      } catch (error) {
        console.error('Message handling error:', error);
      }
    });

    ws.on("pong", () => {
      (ws as any).isAlive = true;
    });

    ws.on("error", (error) => {
      console.error('WebSocket error:', error);
    });

    ws.on("close", async () => {
      const playerId = this.getPlayerIdBySocket(ws);
      if (playerId) {
        await this.handleDisconnect(playerId, ws);
      }
    });

    (ws as any).isAlive = true;
  }

  private getPlayerIdBySocket(ws: WebSocket): string | undefined {
    for (const [playerId, socket] of this.wsMap.entries()) {
      if (socket === ws) return playerId;
    }
    return undefined;
  }

  private async handleMessage(ws: WebSocket, data: any) {
    try {
      switch (data.type) {
        case "join_room":
          await this.handleJoinRoom(data.roomId, data.playerId, ws);
          break;
        case "submit_title":
          console.log()
          await this.handleSubmitTitle(data.data.roomId, data.data.title, data.data.playerId);
          break;
        case "play_card":
          await this.handlePlayCard(data.roomId, data.playerId, data.cardIndex);
          break;
        case "claim_win":
          await this.handleClaimWin(data.roomId, data.playerId);
          break;
        case "room_exit":
          
        default:
          throw new GameError(`Unknown message type: ${data.type}`);
      }
    } catch (error) {
      const handledError = ErrorHandler.handleError(error as Error, 'WebSocketHandler.handleMessage', data.playerId);
      if (handledError instanceof GameError) {
        console.log("Broadcasrting error")
        this.broadcastManager.broadcastError(data.playerId, handledError.message, this.wsMap);
      } else {
        this.broadcastManager.broadcastError(data.playerId, "An unexpected error occurred", this.wsMap);
      }
    }
  }

  private async handleJoinRoom(
    roomId: string,
    playerId: string,
    ws: WebSocket,
  ) {

    this.wsMap.set(playerId, ws);
    await this.broadcastManager.addClient(playerId, roomId, ws)

    const gameStatus = await this.redisManager.getGameStatus(roomId);

    if(gameStatus === "inProgress"){
      await this.broadcastManager.broadCastGameState(roomId,this.wsMap);
    }else{
    await this.broadcastManager.broadcastLobby(roomId, this.wsMap);
    }

  }

  private async handleSubmitTitle(roomId: string, title: string, playerId: string) {

    const allTitlesSubmitted = await this.redisManager.submitTitleAndCheck(roomId, title, playerId);
    console.log("alltitlkes submitted:", allTitlesSubmitted)
    if (allTitlesSubmitted) {
      await this.gameLogic.startGame(roomId);
      console.log("game started")
      await this.delay(2000);
      await this.broadcastManager.broadCastGameState(roomId, this.wsMap, "game_start");
    } else {
      console.log("title submit broadcast")
      this.broadcastManager.broadcastLobby(roomId,this.wsMap)
    }
  }
  delay(ms: number) {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
  private async handlePlayCard(
    roomId: string,
    playerId: string,
    cardIndex: number,
  ) {

    await this.gameLogic.playCard(roomId, playerId, cardIndex);;
    await this.broadcastManager.broadCastGameState(roomId, this.wsMap);
    console.log(`${playerId} passes ${cardIndex}`);
  }

  private async handleLeaveRoom(roomId:string,playerId:string){
    await this.redisManager.removePlayerFromRoom(roomId,playerId)
    this.wsMap.delete(playerId)
    const state = await this.redisManager.getGameStatus(roomId);
    if(state ===  "lobby"){
    await this.broadcastManager.broadcastLobby(roomId,this.wsMap);
  }else if(state === "running"){

  }
  }

  private async handleClaimWin(roomId: string, playerId: string) {
    const isWinner = await this.gameLogic.claimWin(roomId, playerId);
    if (isWinner) {
      const name = (await this.redisManager.getRoomPlayers(roomId)).find(obj => obj.id===playerId)?.name ||null;
      this.broadcastManager.broadCastToRoom(roomId, {
        type: "game_end",
        winner: name,
      }, this.wsMap);
      await this.redisManager.removeRoom(roomId);

    } else {
      this.broadcastManager.broadCastToRoom(roomId, {
        type: "game_continue",
        text: `${playerId} made wrong thap boink`,
      }, this.wsMap);
    }
  }
}
```

## File: src/index.ts
```typescript
import express from "express";
import * as http from "http";
import GameLogic from "@/handlers/gameLogic";
import RedisManager from "@/handlers/redisManager";
import RoomManager from "@/handlers/roomManager";
import WebSocketHandler from "@/websockets/sockethandler";
import BroadcastManager from "@/websockets/broadcastManager";
import bodyParser from "body-parser";
import { ErrorHandler } from '@/utils/ErrorHandler';
import { GameError } from "./utils/GameError";
import { Server } from 'http';
import cors from "cors"

// process.on('SIGTERM', () => shutdown());
// process.on('SIGINT', () => shutdown());

const app = express();
app.use(cors());
app.use(bodyParser.json());
app.use(bodyParser.urlencoded({ extended: true }));

const server = http.createServer(app);

const redisManager = RedisManager.getInstance();
const gameLogic = new GameLogic(redisManager);
const roomManager = new RoomManager();
const broadcastManager = new BroadcastManager(redisManager);
const webSocketHandler = new WebSocketHandler(
  gameLogic,
  redisManager,
  broadcastManager,
);

app.get("/health", async (req, res) => {
  res.send("Running");
});

app.post("/create-room", async (req, res, next) => {
  try {
    const playerId = req.body.playerId;
    const playerName = req.body.playerName;
    const roomId = await roomManager.createRoom(playerId, playerName);
    res.send(roomId);
  } catch (error) {
    next(error);
  }
});

app.post("/join-room", async (req, res) => {
  console.log("join room endpoint called with body:", req.body);
  const roomId = req.body.roomId;
  const playerId = req.body.playerId;
  const playerName = req.body.playerName;
  const success = await roomManager.joinRoom(roomId, playerId,playerName);
  res.send({ success });
}); 

server.on("upgrade", (req, socket, head) => {
  webSocketHandler.onUpgrade(req, socket, head);
});
const PORT = process.env.PORT || 8082;
server.listen(PORT, () => {
  console.log(`Server running on port ${PORT}`);
});

// Error handling middleware
app.use((err: Error, req: express.Request, res: express.Response, next: express.NextFunction) => {
  const handledError = ErrorHandler.handleError(err, 'ExpressServer');
  res.status(500).json({
    error: handledError instanceof GameError ? handledError.message : 'An unexpected error occurred'
  });
});

async function shutdown() {
  console.log('Shutting down gracefully...');
  
  // Close WebSocket connections
  await broadcastManager.cleanup();
  
  // Close Redis connection
  await redisManager.close();
  
  // Close HTTP server
  server.close(() => {
    console.log('HTTP server closed');
    process.exit(0);
  });

  // Force close after 10 seconds
  setTimeout(() => {
    console.error('Could not close connections in time, forcefully shutting down');
    process.exit(1);
  }, 10000);
}
```

## File: .gitignore
```
# Node.js
node_modules/
dist/

# TypeScript
*.tsbuildinfo

# Logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# IDEs and editors
.vscode/
.idea/
*.suo
*.ntvs*
*.njsproj
*.sln
*.sw?


repomix-output.txt

# Miscellaneous
.DS_Store
Thumbs.db
```

## File: .prettierignore
```
# Ignore node_modules
node_modules

# Ignore build outputs
dist
build

# Ignore specific files
*.min.js
*.json
*.md

# Ignore all files in the `public` directory
public/*
```

## File: package.json
```json
{
  "name": "parchi",
  "version": "1.0.0",
  "description": "",
  "main": "index.js",
  "scripts": {
    "dev": "ts-node-dev --respawn --transpile-only --require tsconfig-paths/register src/index.ts",
    "build": "tsc",
    "start": "tsc -b node dist/index.js",
    "test": "echo \"Error: no test specified\" && exit 1"
  },
  "keywords": [],
  "author": "",
  "license": "ISC",
  "dependencies": {
    "@types/cors": "^2.8.17",
    "body-parser": "^1.20.3",
    "cors": "^2.8.5",
    "express": "^4.21.1",
    "redis": "^4.7.0",
    "uuid": "^10.0.0",
    "winston": "^3.17.0",
    "ws": "^8.18.0"
  },
  "devDependencies": {
    "@types/body-parser": "^1.19.5",
    "@types/express": "^5.0.0",
    "@types/node": "^22.7.6",
    "@types/uuid": "^10.0.0",
    "@types/ws": "^8.5.12",
    "prettier": "^3.3.3",
    "ts-node-dev": "^2.0.0",
    "tsconfig-paths": "^4.2.0",
    "typescript": "^5.6.3"
  }
}
```

## File: tsconfig.json
```json
{
  "compilerOptions": {
    "target": "ES6",                                
    "module": "commonjs",                           
    "strict": true,                                
    "esModuleInterop": true,                       
    "skipLibCheck": true,                          
    "forceConsistentCasingInFileNames": true,      
    "outDir": "./dist",                            
    "rootDir": "./src",
    "baseUrl": "./",
    "paths": {
      "@/*": ["src/*"]
    }                             
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules"]
}
```
